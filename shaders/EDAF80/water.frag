#version 410 core  in VS_OUT {     vec3 vertex;       // world space position     vec3 normal;       // world space normal     vec2 texCoord;     // UV      // Animated normal mapping      vec2 normalCoord0;     vec2 normalCoord1;     vec2 normalCoord2;      // Tangent → World     mat3 TBN; } fs_in;  out vec4 frag_color;  // === uniform === uniform samplerCube cubemap;        uniform sampler2D   normalTexture; // Animated normal mapping waves.png uniform vec3        camera_position; // Camera world position   void main() {     // ---------- Animated normal mapping ----------     // 1. 3 uv sample same normal map     vec3 n0 = texture(normalTexture, fs_in.normalCoord0).xyz * 2.0 - 1.0;     vec3 n1 = texture(normalTexture, fs_in.normalCoord1).xyz * 2.0 - 1.0;     vec3 n2 = texture(normalTexture, fs_in.normalCoord2).xyz * 2.0 - 1.0;      // 2. superposion and nomalization（tangent space）     vec3 nbump_ts = normalize(n0 + n1 + n2);      // 3. tangent space → world space     vec3 n = -normalize(fs_in.TBN * nbump_ts);      // view vector and normal vector      vec3 V = normalize(camera_position - fs_in.vertex);  // view vector (surface → camera)      // ---------- color water ----------     vec4 colordeep    = vec4(0.0, 0.0, 0.1, 1.0);     vec4 colorshallow = vec4(0.0, 0.5, 0.5, 1.0);      // facing term：VN larger → deeper color     float facing = 1.0 - max(dot(V, n), 0.0);     vec4 colorwater = mix(colordeep, colorshallow, facing);      // ---------- reflection term ----------     vec3 R = reflect(-V, n);     vec3 reflection = texture(cubemap, R).rgb;      // ---------- Fresnel  ----------     float R0 = 0.02037; // air(1.0) → water(1.33)     float fresnel = R0 + (1.0 - R0) * pow(1.0 - max(dot(V, n), 0.0), 5.0);      // ---------- refrection ----------     float eta = 1.0 / 1.33; // air → water     vec3 refrectionDir = refract(-V, n, eta);     vec3 refraction = texture(cubemap, refrectionDir).rgb;      // ---------- final synatic ----------     vec3 finalColor = colorwater.rgb                     + reflection * fresnel                     + refraction * (1.0 - fresnel);      frag_color = vec4(finalColor, 1.0); 	frag_color = vec4(n*0.5+0.5, 1.0); } 